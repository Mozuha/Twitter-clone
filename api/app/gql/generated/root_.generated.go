// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"app/ent"
	"bytes"
	"context"
	"errors"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Like struct {
		BelongTo func(childComplexity int) int
		ID       func(childComplexity int) int
		PutBy    func(childComplexity int) int
		TweetID  func(childComplexity int) int
		UserID   func(childComplexity int) int
	}

	Mutation struct {
		CreateUser func(childComplexity int, input ent.CreateUserInput) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Query struct {
		Likes  func(childComplexity int) int
		Node   func(childComplexity int, id int) int
		Nodes  func(childComplexity int, ids []int) int
		Tweets func(childComplexity int) int
		Users  func(childComplexity int) int
	}

	Tweet struct {
		Child     func(childComplexity int) int
		CreatedAt func(childComplexity int) int
		Has       func(childComplexity int) int
		ID        func(childComplexity int) int
		Parent    func(childComplexity int) int
		ParentID  func(childComplexity int) int
		PostedBy  func(childComplexity int) int
		Text      func(childComplexity int) int
		UserID    func(childComplexity int) int
	}

	User struct {
		CreatedAt    func(childComplexity int) int
		Email        func(childComplexity int) int
		Followers    func(childComplexity int) int
		Following    func(childComplexity int) int
		ID           func(childComplexity int) int
		Name         func(childComplexity int) int
		Password     func(childComplexity int) int
		Posts        func(childComplexity int) int
		ProfileImage func(childComplexity int) int
		Puts         func(childComplexity int) int
		ScreenName   func(childComplexity int) int
		UpdatedAt    func(childComplexity int) int
	}
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "Like.belongTo":
		if e.complexity.Like.BelongTo == nil {
			break
		}

		return e.complexity.Like.BelongTo(childComplexity), true

	case "Like.id":
		if e.complexity.Like.ID == nil {
			break
		}

		return e.complexity.Like.ID(childComplexity), true

	case "Like.putBy":
		if e.complexity.Like.PutBy == nil {
			break
		}

		return e.complexity.Like.PutBy(childComplexity), true

	case "Like.tweetID":
		if e.complexity.Like.TweetID == nil {
			break
		}

		return e.complexity.Like.TweetID(childComplexity), true

	case "Like.userID":
		if e.complexity.Like.UserID == nil {
			break
		}

		return e.complexity.Like.UserID(childComplexity), true

	case "Mutation.createUser":
		if e.complexity.Mutation.CreateUser == nil {
			break
		}

		args, err := ec.field_Mutation_createUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateUser(childComplexity, args["input"].(ent.CreateUserInput)), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Query.likes":
		if e.complexity.Query.Likes == nil {
			break
		}

		return e.complexity.Query.Likes(childComplexity), true

	case "Query.node":
		if e.complexity.Query.Node == nil {
			break
		}

		args, err := ec.field_Query_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Node(childComplexity, args["id"].(int)), true

	case "Query.nodes":
		if e.complexity.Query.Nodes == nil {
			break
		}

		args, err := ec.field_Query_nodes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Nodes(childComplexity, args["ids"].([]int)), true

	case "Query.tweets":
		if e.complexity.Query.Tweets == nil {
			break
		}

		return e.complexity.Query.Tweets(childComplexity), true

	case "Query.users":
		if e.complexity.Query.Users == nil {
			break
		}

		return e.complexity.Query.Users(childComplexity), true

	case "Tweet.child":
		if e.complexity.Tweet.Child == nil {
			break
		}

		return e.complexity.Tweet.Child(childComplexity), true

	case "Tweet.createdAt":
		if e.complexity.Tweet.CreatedAt == nil {
			break
		}

		return e.complexity.Tweet.CreatedAt(childComplexity), true

	case "Tweet.has":
		if e.complexity.Tweet.Has == nil {
			break
		}

		return e.complexity.Tweet.Has(childComplexity), true

	case "Tweet.id":
		if e.complexity.Tweet.ID == nil {
			break
		}

		return e.complexity.Tweet.ID(childComplexity), true

	case "Tweet.parent":
		if e.complexity.Tweet.Parent == nil {
			break
		}

		return e.complexity.Tweet.Parent(childComplexity), true

	case "Tweet.parentID":
		if e.complexity.Tweet.ParentID == nil {
			break
		}

		return e.complexity.Tweet.ParentID(childComplexity), true

	case "Tweet.postedBy":
		if e.complexity.Tweet.PostedBy == nil {
			break
		}

		return e.complexity.Tweet.PostedBy(childComplexity), true

	case "Tweet.text":
		if e.complexity.Tweet.Text == nil {
			break
		}

		return e.complexity.Tweet.Text(childComplexity), true

	case "Tweet.userID":
		if e.complexity.Tweet.UserID == nil {
			break
		}

		return e.complexity.Tweet.UserID(childComplexity), true

	case "User.createdAt":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.followers":
		if e.complexity.User.Followers == nil {
			break
		}

		return e.complexity.User.Followers(childComplexity), true

	case "User.following":
		if e.complexity.User.Following == nil {
			break
		}

		return e.complexity.User.Following(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	case "User.password":
		if e.complexity.User.Password == nil {
			break
		}

		return e.complexity.User.Password(childComplexity), true

	case "User.posts":
		if e.complexity.User.Posts == nil {
			break
		}

		return e.complexity.User.Posts(childComplexity), true

	case "User.profileImage":
		if e.complexity.User.ProfileImage == nil {
			break
		}

		return e.complexity.User.ProfileImage(childComplexity), true

	case "User.puts":
		if e.complexity.User.Puts == nil {
			break
		}

		return e.complexity.User.Puts(childComplexity), true

	case "User.screenName":
		if e.complexity.User.ScreenName == nil {
			break
		}

		return e.complexity.User.ScreenName(childComplexity), true

	case "User.updatedAt":
		if e.complexity.User.UpdatedAt == nil {
			break
		}

		return e.complexity.User.UpdatedAt(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputCreateLikeInput,
		ec.unmarshalInputCreateTweetInput,
		ec.unmarshalInputCreateUserInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../../ent/ent.graphql", Input: `directive @goField(forceResolver: Boolean, name: String) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @goModel(model: String, models: [String!]) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION
"""
CreateLikeInput is used for create Like object.
Input was generated by ent.
"""
input CreateLikeInput {
  userID: Int!
  tweetID: Int!
  putByID: ID!
  belongToID: ID!
}
"""
CreateTweetInput is used for create Tweet object.
Input was generated by ent.
"""
input CreateTweetInput {
  text: String!
  parentID: Int
  userID: Int!
  createdAt: Time
  postedByID: ID!
  childIDs: [ID!]
  parentIDs: [ID!]
  haIDs: [ID!]
}
"""
CreateUserInput is used for create User object.
Input was generated by ent.
"""
input CreateUserInput {
  name: String!
  screenName: String!
  email: String!
  password: String!
  profileImage: String!
  createdAt: Time
  updatedAt: Time
  postIDs: [ID!]
  followerIDs: [ID!]
  followingIDs: [ID!]
  putIDs: [ID!]
}
"""
Define a Relay Cursor type:
https://relay.dev/graphql/connections.htm#sec-Cursor
"""
scalar Cursor
type Like implements Node {
  id: ID!
  userID: Int!
  tweetID: Int!
  putBy: User!
  belongTo: Tweet!
}
"""
An object with an ID.
Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
"""
interface Node @goModel(model: "app/ent.Noder") {
  """The id of the object."""
  id: ID!
}
"""Possible directions in which to order a list of items when provided an ` + "`" + `orderBy` + "`" + ` argument."""
enum OrderDirection {
  """Specifies an ascending order for a given ` + "`" + `orderBy` + "`" + ` argument."""
  ASC
  """Specifies a descending order for a given ` + "`" + `orderBy` + "`" + ` argument."""
  DESC
}
"""
Information about pagination in a connection.
https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
"""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!
  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!
  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor
  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor
}
type Query {
  """Fetches an object given its ID."""
  node(
    """ID of the object."""
    id: ID!
  ): Node
  """Lookup nodes by a list of IDs."""
  nodes(
    """The list of node IDs."""
    ids: [ID!]!
  ): [Node]!
  likes: [Like!]!
  tweets: [Tweet!]!
  users: [User!]!
}
"""The builtin Time type"""
scalar Time
type Tweet implements Node {
  id: ID!
  text: String!
  parentID: Int
  userID: Int!
  createdAt: Time!
  postedBy: User!
  child: [Tweet!]
  parent: [Tweet!]
  has: [Like!]
}
type User implements Node {
  id: ID!
  name: String!
  screenName: String!
  email: String!
  password: String!
  profileImage: String!
  createdAt: Time!
  updatedAt: Time!
  posts: [Tweet!]
  followers: [User!]
  following: [User!]
  puts: [Like!]
}
`, BuiltIn: false},
	{Name: "../../ent/user.graphql", Input: `type Mutation {
  createUser(input: CreateUserInput!): User
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
