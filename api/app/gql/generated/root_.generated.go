// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"app/ent"
	"bytes"
	"context"
	"errors"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Mutation struct {
		CreateTweet func(childComplexity int, input ent.CreateTweetInput) int
		CreateUser  func(childComplexity int, input ent.CreateUserInput) int
		DeleteTweet func(childComplexity int, id int) int
		DeleteUser  func(childComplexity int, id int) int
		UpdateUser  func(childComplexity int, id int, input ent.UpdateUserInput) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Query struct {
		Node   func(childComplexity int, id int) int
		Nodes  func(childComplexity int, ids []int) int
		Tweets func(childComplexity int, where *ent.TweetWhereInput) int
		Users  func(childComplexity int, where *ent.UserWhereInput) int
	}

	Tweet struct {
		Children  func(childComplexity int) int
		CreatedAt func(childComplexity int) int
		ID        func(childComplexity int) int
		LikedBy   func(childComplexity int) int
		Parent    func(childComplexity int) int
		PostedBy  func(childComplexity int) int
		Text      func(childComplexity int) int
	}

	User struct {
		CreatedAt    func(childComplexity int) int
		Email        func(childComplexity int) int
		Followers    func(childComplexity int) int
		Following    func(childComplexity int) int
		ID           func(childComplexity int) int
		Likes        func(childComplexity int) int
		Name         func(childComplexity int) int
		Posts        func(childComplexity int) int
		ProfileImage func(childComplexity int) int
		ScreenName   func(childComplexity int) int
		UpdatedAt    func(childComplexity int) int
	}
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "Mutation.createTweet":
		if e.complexity.Mutation.CreateTweet == nil {
			break
		}

		args, err := ec.field_Mutation_createTweet_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateTweet(childComplexity, args["input"].(ent.CreateTweetInput)), true

	case "Mutation.createUser":
		if e.complexity.Mutation.CreateUser == nil {
			break
		}

		args, err := ec.field_Mutation_createUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateUser(childComplexity, args["input"].(ent.CreateUserInput)), true

	case "Mutation.deleteTweet":
		if e.complexity.Mutation.DeleteTweet == nil {
			break
		}

		args, err := ec.field_Mutation_deleteTweet_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteTweet(childComplexity, args["id"].(int)), true

	case "Mutation.deleteUser":
		if e.complexity.Mutation.DeleteUser == nil {
			break
		}

		args, err := ec.field_Mutation_deleteUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteUser(childComplexity, args["id"].(int)), true

	case "Mutation.updateUser":
		if e.complexity.Mutation.UpdateUser == nil {
			break
		}

		args, err := ec.field_Mutation_updateUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUser(childComplexity, args["id"].(int), args["input"].(ent.UpdateUserInput)), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Query.node":
		if e.complexity.Query.Node == nil {
			break
		}

		args, err := ec.field_Query_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Node(childComplexity, args["id"].(int)), true

	case "Query.nodes":
		if e.complexity.Query.Nodes == nil {
			break
		}

		args, err := ec.field_Query_nodes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Nodes(childComplexity, args["ids"].([]int)), true

	case "Query.tweets":
		if e.complexity.Query.Tweets == nil {
			break
		}

		args, err := ec.field_Query_tweets_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Tweets(childComplexity, args["where"].(*ent.TweetWhereInput)), true

	case "Query.users":
		if e.complexity.Query.Users == nil {
			break
		}

		args, err := ec.field_Query_users_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Users(childComplexity, args["where"].(*ent.UserWhereInput)), true

	case "Tweet.children":
		if e.complexity.Tweet.Children == nil {
			break
		}

		return e.complexity.Tweet.Children(childComplexity), true

	case "Tweet.createdAt":
		if e.complexity.Tweet.CreatedAt == nil {
			break
		}

		return e.complexity.Tweet.CreatedAt(childComplexity), true

	case "Tweet.id":
		if e.complexity.Tweet.ID == nil {
			break
		}

		return e.complexity.Tweet.ID(childComplexity), true

	case "Tweet.likedBy":
		if e.complexity.Tweet.LikedBy == nil {
			break
		}

		return e.complexity.Tweet.LikedBy(childComplexity), true

	case "Tweet.parent":
		if e.complexity.Tweet.Parent == nil {
			break
		}

		return e.complexity.Tweet.Parent(childComplexity), true

	case "Tweet.postedBy":
		if e.complexity.Tweet.PostedBy == nil {
			break
		}

		return e.complexity.Tweet.PostedBy(childComplexity), true

	case "Tweet.text":
		if e.complexity.Tweet.Text == nil {
			break
		}

		return e.complexity.Tweet.Text(childComplexity), true

	case "User.createdAt":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.followers":
		if e.complexity.User.Followers == nil {
			break
		}

		return e.complexity.User.Followers(childComplexity), true

	case "User.following":
		if e.complexity.User.Following == nil {
			break
		}

		return e.complexity.User.Following(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.likes":
		if e.complexity.User.Likes == nil {
			break
		}

		return e.complexity.User.Likes(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	case "User.posts":
		if e.complexity.User.Posts == nil {
			break
		}

		return e.complexity.User.Posts(childComplexity), true

	case "User.profileImage":
		if e.complexity.User.ProfileImage == nil {
			break
		}

		return e.complexity.User.ProfileImage(childComplexity), true

	case "User.screenName":
		if e.complexity.User.ScreenName == nil {
			break
		}

		return e.complexity.User.ScreenName(childComplexity), true

	case "User.updatedAt":
		if e.complexity.User.UpdatedAt == nil {
			break
		}

		return e.complexity.User.UpdatedAt(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputCreateTweetInput,
		ec.unmarshalInputCreateUserInput,
		ec.unmarshalInputTweetOrder,
		ec.unmarshalInputTweetWhereInput,
		ec.unmarshalInputUpdateUserInput,
		ec.unmarshalInputUserOrder,
		ec.unmarshalInputUserWhereInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/ent.graphql", Input: `directive @goField(forceResolver: Boolean, name: String) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @goModel(model: String, models: [String!]) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION
"""
CreateTweetInput is used for create Tweet object.
Input was generated by ent.
"""
input CreateTweetInput {
  text: String!
  createdAt: Time
  postedByID: ID!
  childIDs: [ID!]
  parentID: ID
  likedByIDs: [ID!]
}
"""
CreateUserInput is used for create User object.
Input was generated by ent.
"""
input CreateUserInput {
  name: String!
  screenName: String!
  email: String!
  password: String!
  profileImage: String
  createdAt: Time
  updatedAt: Time
  postIDs: [ID!]
  followerIDs: [ID!]
  followingIDs: [ID!]
  likeIDs: [ID!]
}
"""
Define a Relay Cursor type:
https://relay.dev/graphql/connections.htm#sec-Cursor
"""
scalar Cursor
"""
An object with an ID.
Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
"""
interface Node @goModel(model: "app/ent.Noder") {
  """The id of the object."""
  id: ID!
}
"""Possible directions in which to order a list of items when provided an ` + "`" + `orderBy` + "`" + ` argument."""
enum OrderDirection {
  """Specifies an ascending order for a given ` + "`" + `orderBy` + "`" + ` argument."""
  ASC
  """Specifies a descending order for a given ` + "`" + `orderBy` + "`" + ` argument."""
  DESC
}
"""
Information about pagination in a connection.
https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
"""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!
  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!
  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor
  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor
}
type Query {
  """Fetches an object given its ID."""
  node(
    """ID of the object."""
    id: ID!
  ): Node
  """Lookup nodes by a list of IDs."""
  nodes(
    """The list of node IDs."""
    ids: [ID!]!
  ): [Node]!
  tweets(where: TweetWhereInput): [Tweet!]!
  users(where: UserWhereInput): [User!]!
}
"""The builtin Time type"""
scalar Time
type Tweet implements Node {
  id: ID!
  text: String!
  createdAt: Time!
  postedBy: User!
  children: [Tweet!]
  parent: Tweet
  likedBy: [User!]
}
"""Ordering options for Tweet connections"""
input TweetOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Tweets."""
  field: TweetOrderField!
}
"""Properties by which Tweet connections can be ordered."""
enum TweetOrderField {
  CREATED_AT
}
"""
TweetWhereInput is used for filtering Tweet objects.
Input was generated by ent.
"""
input TweetWhereInput {
  not: TweetWhereInput
  and: [TweetWhereInput!]
  or: [TweetWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """text field predicates"""
  text: String
  textNEQ: String
  textIn: [String!]
  textNotIn: [String!]
  textGT: String
  textGTE: String
  textLT: String
  textLTE: String
  textContains: String
  textHasPrefix: String
  textHasSuffix: String
  textEqualFold: String
  textContainsFold: String
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """posted_by edge predicates"""
  hasPostedBy: Boolean
  hasPostedByWith: [UserWhereInput!]
  """children edge predicates"""
  hasChildren: Boolean
  hasChildrenWith: [TweetWhereInput!]
  """parent edge predicates"""
  hasParent: Boolean
  hasParentWith: [TweetWhereInput!]
  """liked_by edge predicates"""
  hasLikedBy: Boolean
  hasLikedByWith: [UserWhereInput!]
}
"""
UpdateUserInput is used for update User object.
Input was generated by ent.
"""
input UpdateUserInput {
  name: String
  screenName: String
  email: String
  password: String
  profileImage: String
  updatedAt: Time
  addPostIDs: [ID!]
  removePostIDs: [ID!]
  clearPosts: Boolean
  addFollowerIDs: [ID!]
  removeFollowerIDs: [ID!]
  clearFollowers: Boolean
  addFollowingIDs: [ID!]
  removeFollowingIDs: [ID!]
  clearFollowing: Boolean
  addLikeIDs: [ID!]
  removeLikeIDs: [ID!]
  clearLikes: Boolean
}
type User implements Node {
  id: ID!
  name: String!
  screenName: String!
  email: String!
  profileImage: String!
  createdAt: Time!
  updatedAt: Time!
  posts: [Tweet!]
  followers: [User!]
  following: [User!]
  likes: [Tweet!]
}
"""Ordering options for User connections"""
input UserOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Users."""
  field: UserOrderField!
}
"""Properties by which User connections can be ordered."""
enum UserOrderField {
  NAME
  SCREEN_NAME
  CREATED_AT
  UPDATED_AT
}
"""
UserWhereInput is used for filtering User objects.
Input was generated by ent.
"""
input UserWhereInput {
  not: UserWhereInput
  and: [UserWhereInput!]
  or: [UserWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """screen_name field predicates"""
  screenName: String
  screenNameNEQ: String
  screenNameIn: [String!]
  screenNameNotIn: [String!]
  screenNameGT: String
  screenNameGTE: String
  screenNameLT: String
  screenNameLTE: String
  screenNameContains: String
  screenNameHasPrefix: String
  screenNameHasSuffix: String
  screenNameEqualFold: String
  screenNameContainsFold: String
  """email field predicates"""
  email: String
  emailNEQ: String
  emailIn: [String!]
  emailNotIn: [String!]
  emailGT: String
  emailGTE: String
  emailLT: String
  emailLTE: String
  emailContains: String
  emailHasPrefix: String
  emailHasSuffix: String
  emailEqualFold: String
  emailContainsFold: String
  """profile_image field predicates"""
  profileImage: String
  profileImageNEQ: String
  profileImageIn: [String!]
  profileImageNotIn: [String!]
  profileImageGT: String
  profileImageGTE: String
  profileImageLT: String
  profileImageLTE: String
  profileImageContains: String
  profileImageHasPrefix: String
  profileImageHasSuffix: String
  profileImageEqualFold: String
  profileImageContainsFold: String
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """posts edge predicates"""
  hasPosts: Boolean
  hasPostsWith: [TweetWhereInput!]
  """followers edge predicates"""
  hasFollowers: Boolean
  hasFollowersWith: [UserWhereInput!]
  """following edge predicates"""
  hasFollowing: Boolean
  hasFollowingWith: [UserWhereInput!]
  """likes edge predicates"""
  hasLikes: Boolean
  hasLikesWith: [TweetWhereInput!]
}
`, BuiltIn: false},
	{Name: "../schema/mutation.graphql", Input: `type Mutation {
  createUser(input: CreateUserInput!): User!
  updateUser(id: ID!, input: UpdateUserInput!): User!
  deleteUser(id: ID!): Boolean # Ent delete operation does not return the deleted entity; Use Boolean to mimic the behaviour of returning nothing
  createTweet(input: CreateTweetInput!): Tweet!
  deleteTweet(id: ID!): Boolean
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
